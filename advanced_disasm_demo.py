#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Advanced Disassembly Demo
Demonstrates multiple Python libraries for better disassembly results
"""

import os
import sys

def install_required_packages():
    """
    Install required packages for advanced disassembly
    """
    packages = [
        'angr',
        'r2pipe', 
        'pefile',
        'capstone'
    ]
    
    print("Installing required packages...")
    for package in packages:
        try:
            __import__(package)
            print(f"âœ“ {package} already installed")
        except ImportError:
            print(f"Installing {package}...")
            os.system(f"pip install {package}")

def disasm_with_angr(binary_path, output_path):
    """
    Use angr for advanced disassembly with CFG analysis
    """
    try:
        import angr
        print("\n=== Using angr for disassembly ===")
        
        # Load binary
        project = angr.Project(binary_path, auto_load_libs=False)
        
        # Generate CFG (Control Flow Graph)
        cfg = project.analyses.CFGFast()
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("; Generated by angr\n")
            f.write("; Advanced disassembly with control flow analysis\n\n")
            
            # Write data section placeholder
            f.write(".data\n")
            f.write("; Data definitions would go here\n\n")
            
            f.write(".code\n")
            
            # Process functions found by CFG
            for func_addr in cfg.functions:
                func = cfg.functions[func_addr]
                func_name = func.name if func.name else f"sub_{func_addr:x}"
                
                f.write(f"\n; Function: {func_name} at 0x{func_addr:x}\n")
                f.write(f"{func_name} PROC\n")
                
                # Get basic blocks in function
                for block in func.blocks:
                    # Disassemble block
                    block_bytes = project.loader.memory.load(block.addr, block.size)
                    
                    # Use capstone for instruction disassembly
                    from capstone import Cs, CS_ARCH_X86, CS_MODE_64
                    md = Cs(CS_ARCH_X86, CS_MODE_64)
                    
                    for insn in md.disasm(block_bytes, block.addr):
                        f.write(f"    {insn.mnemonic} {insn.op_str}\n")
                
                f.write(f"{func_name} ENDP\n")
            
            f.write("\nEND\n")
        
        print(f"angr disassembly written to: {output_path}")
        return True
        
    except ImportError:
        print("angr not available. Install with: pip install angr")
        return False
    except Exception as e:
        print(f"Error with angr: {e}")
        return False

def disasm_with_r2pipe(binary_path, output_path):
    """
    Use radare2 via r2pipe for disassembly
    """
    try:
        import r2pipe
        print("\n=== Using radare2 (r2pipe) for disassembly ===")
        
        # Open binary with radare2
        r2 = r2pipe.open(binary_path)
        
        # Analyze binary
        r2.cmd('aaa')  # Analyze all
        
        # Get functions
        functions = r2.cmdj('aflj')  # Get functions as JSON
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("; Generated by radare2 (r2pipe)\n")
            f.write("; Advanced disassembly with radare2 analysis\n\n")
            
            f.write(".data\n")
            f.write("; Data sections\n")
            
            # Get data sections
            sections = r2.cmdj('iSj')
            for section in sections:
                if section.get('perm', '') == 'r--':  # Read-only data
                    f.write(f"; Section: {section.get('name', 'unknown')}\n")
            
            f.write("\n.code\n")
            
            # Process each function
            if functions:
                for func in functions:
                    func_name = func.get('name', f"sub_{func.get('offset', 0):x}")
                    func_addr = func.get('offset', 0)
                    
                    f.write(f"\n; Function: {func_name}\n")
                    f.write(f"{func_name} PROC\n")
                    
                    # Get disassembly for function
                    r2.cmd(f's {func_addr}')  # Seek to function
                    disasm = r2.cmd('pdf')    # Print disassembly of function
                    
                    # Parse and clean up disassembly
                    lines = disasm.split('\n')
                    for line in lines:
                        line = line.strip()
                        if line and not line.startswith('/') and not line.startswith(';'):
                            # Extract instruction part
                            parts = line.split()
                            if len(parts) >= 2:
                                # Skip address and hex bytes, get instruction
                                instruction_start = line.find(parts[-2] if len(parts) > 2 else parts[-1])
                                if instruction_start > 0:
                                    instruction = line[instruction_start:]
                                    f.write(f"    {instruction}\n")
                    
                    f.write(f"{func_name} ENDP\n")
            
            f.write("\nEND\n")
        
        r2.quit()
        print(f"radare2 disassembly written to: {output_path}")
        return True
        
    except ImportError:
        print("r2pipe not available. Install with: pip install r2pipe")
        print("Also requires radare2 to be installed on system")
        return False
    except Exception as e:
        print(f"Error with radare2: {e}")
        return False

def disasm_with_pefile_capstone(binary_path, output_path):
    """
    Enhanced disassembly using pefile + capstone with better structure
    """
    try:
        import pefile
        from capstone import Cs, CS_ARCH_X86, CS_MODE_64
        
        print("\n=== Using pefile + capstone (enhanced) ===")
        
        # Load PE file
        pe = pefile.PE(binary_path)
        
        # Get entry point
        entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint
        image_base = pe.OPTIONAL_HEADER.ImageBase
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("; Generated by pefile + capstone (enhanced)\n")
            f.write(f"; Entry point: 0x{entry_point:x}\n")
            f.write(f"; Image base: 0x{image_base:x}\n\n")
            
            # Write data sections
            f.write(".data\n")
            for section in pe.sections:
                section_name = section.Name.decode('utf-8').rstrip('\x00')
                if '.data' in section_name or '.rdata' in section_name:
                    f.write(f"; Section: {section_name}\n")
                    f.write(f"; Virtual Address: 0x{section.VirtualAddress:x}\n")
                    f.write(f"; Size: 0x{section.Misc_VirtualSize:x}\n")
            f.write("\n")
            
            # Write code section
            f.write(".code\n")
            f.write("\n; Entry point\n")
            f.write("main PROC\n")
            
            # Find and disassemble code sections
            md = Cs(CS_ARCH_X86, CS_MODE_64)
            md.detail = True
            
            for section in pe.sections:
                section_name = section.Name.decode('utf-8').rstrip('\x00')
                if '.text' in section_name or section.Characteristics & 0x20000000:  # Executable
                    code_data = section.get_data()
                    base_addr = image_base + section.VirtualAddress
                    
                    f.write(f"\n; Section: {section_name}\n")
                    
                    # Disassemble with better formatting
                    prev_addr = None
                    for insn in md.disasm(code_data, base_addr):
                        # Add labels for jump targets (simplified)
                        if prev_addr and insn.address - prev_addr > 4:
                            f.write(f"\nloc_{insn.address:x}:\n")
                        
                        # Format instruction
                        f.write(f"    {insn.mnemonic} {insn.op_str}\n")
                        prev_addr = insn.address
            
            f.write("main ENDP\n")
            f.write("\nEND\n")
        
        print(f"Enhanced pefile+capstone disassembly written to: {output_path}")
        return True
        
    except ImportError as e:
        print(f"Required packages not available: {e}")
        return False
    except Exception as e:
        print(f"Error with pefile+capstone: {e}")
        return False

def main():
    """
    Main function - try different disassembly approaches
    """
    print("Advanced Disassembly Demo")
    print("=========================")
    
    binary_path = "hello2.exe"
    if not os.path.exists(binary_path):
        print(f"Binary file {binary_path} not found")
        return
    
    print(f"Analyzing: {binary_path}")
    
    # Try different approaches
    approaches = [
        ("angr", "hello_angr_disasm.asm", disasm_with_angr),
        ("r2pipe", "hello_r2_disasm.asm", disasm_with_r2pipe),
        ("pefile+capstone", "hello_enhanced_disasm.asm", disasm_with_pefile_capstone)
    ]
    
    successful = []
    
    for name, output_file, func in approaches:
        print(f"\nTrying {name}...")
        if func(binary_path, output_file):
            successful.append((name, output_file))
        else:
            print(f"Failed to use {name}")
    
    print("\n" + "="*50)
    print("SUMMARY")
    print("="*50)
    
    if successful:
        print("Successfully generated assembly files:")
        for name, output_file in successful:
            print(f"  - {name}: {output_file}")
        
        print("\nRecommendations:")
        print("1. Compare the generated files to see which provides better structure")
        print("2. angr provides the most advanced analysis (CFG, function detection)")
        print("3. radare2 offers comprehensive reverse engineering features")
        print("4. pefile+capstone gives you the most control over the process")
        print("\nFor best results, try compiling the generated assembly files")
        print("and see which one works best for your specific binary.")
    else:
        print("No disassembly methods were successful.")
        print("Try installing the required packages:")
        print("  pip install angr r2pipe pefile capstone")

if __name__ == "__main__":
    main()